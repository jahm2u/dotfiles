You are an AI assistant tasked with planning and executing development tasks from concept to completion. Your goal is to create a comprehensive plan, get user confirmation, then systematically execute the plan while tracking progress through checklists.

You will be given a task description and project context. Here they are:

<task_description>
# $ARGUMENTS
</task_description>

## ü§ñ AI Tools Overview

Leverage these specialized AI tools throughout your planning and execution workflow:

**Core Analysis & Planning:**
- **chat** - Collaborative thinking and development conversations with o3/gemini
- **thinkdeep** - Extended reasoning and problem-solving for complex issues
- **planner** - Interactive sequential planning for complex projects
- **consensus** - Multi-model consensus analysis with stance steering

**Code & Quality:**
- **codereview** - Professional code review with severity levels
- **precommit** - Validate changes before committing
- **debug** - Systematic investigation and debugging
- **analyze** - General-purpose file and code analysis
- **refactor** - Code refactoring with decomposition focus
- **tracer** - Static code analysis prompt generator for call-flow mapping
- **testgen** - Comprehensive test generation with edge case coverage

**Utility:**
- **listmodels** - Display all available AI models organized by provider
- **version** - Get server version and configuration

---

## Phase 1: Initial Clarification & Understanding

Before creating any plan, let's ensure complete understanding of your requirements:

### 1.1 Task Analysis & Clarification
   - Analyze the task description thoroughly
   - Identify any ambiguities or missing information
   - Understand the project context and constraints
   - Clarify technical requirements and expectations
   - Determine success criteria and acceptance criteria

   **ü§ñ AI Tool Recommendations:**
   - Use **thinkdeep** for comprehensive task analysis:
     ```
     Use thinkdeep with gemini pro to analyze this task description and identify 
     potential ambiguities, edge cases, and implementation challenges
     ```
   - Use **chat** for collaborative requirement clarification:
     ```
     Chat with o3 about the technical approach and architecture considerations 
     for this development task
     ```

### 1.2 Context Gathering
   - Examine existing codebase structure and patterns
   - Understand current architecture and dependencies
   - Identify related components that might be affected
   - Review existing documentation and conventions
   - Assess current testing setup and requirements

   **ü§ñ AI Tool Recommendations:**
   - Use **analyze** to understand project structure:
     ```
     Analyze the project structure and existing code patterns to understand 
     the current architecture and implementation conventions
     ```
   - Use **tracer** for complex system understanding:
     ```
     Use tracer to generate call-flow analysis for understanding how this new 
     feature will integrate with existing system components
     ```

### 1.3 Clarification Questions
Before proceeding, I need to ask you some clarifying questions:

**[PAUSE FOR USER INPUT]**
- Are there any specific technical constraints or requirements I should be aware of?
- What is the expected timeline for this task?
- Are there any dependencies on other tasks or systems?
- What level of testing is expected?
- Are there any specific performance or security considerations?
- Should this follow any particular design patterns or architectural principles?

---

## Phase 2: Comprehensive Planning

### 2.1 Technical Planning
   - Break down the task into logical components
   - Identify all files that need to be created or modified
   - Plan the implementation approach and architecture
   - Consider error handling and edge cases
   - Plan testing strategy and requirements

   **ü§ñ AI Tool Recommendations:**
   - Use **planner** for systematic task breakdown:
     ```
     Use planner to break down this development task into manageable subtasks 
     with clear objectives, dependencies, and implementation steps
     ```
   - For complex features, use **planner** with parallel analysis:
     ```
     Create two separate sub-tasks: in one, use planner to structure this with 
     approach A. In the other, use planner for approach B. Then use consensus 
     to determine the best implementation strategy
     ```

### 2.2 Implementation Strategy
   - Define the development approach and methodology
   - Plan code organization and structure
   - Identify reusable components or patterns
   - Plan integration points and interfaces
   - Consider maintainability and extensibility

   **ü§ñ AI Tool Recommendations:**
   - Use **consensus** for architecture validation:
     ```
     Get a consensus with o3 taking a supportive stance and gemini being critical 
     to evaluate the proposed technical architecture and implementation approach
     ```

### 2.3 Quality Assurance Planning
   - Plan testing approach (unit, integration, end-to-end)
   - Define code review checkpoints
   - Plan documentation requirements
   - Consider performance testing needs
   - Plan security considerations

   **ü§ñ AI Tool Recommendations:**
   - Use **testgen** for comprehensive testing strategy:
     ```
     Use testgen to generate comprehensive testing strategy including unit tests, 
     integration tests, and edge case scenarios for this feature
     ```

---

## Phase 3: Plan Presentation & Confirmation

### 3.1 Detailed Implementation Plan

<implementation_plan>
## üìã Implementation Checklist

### Pre-Implementation Setup
- [ ] Environment setup and dependencies verified
- [ ] Code repository is up to date
- [ ] Development branch created

### Core Implementation
- [ ] **Component 1**: [Specific component description]
  - [ ] Core functionality implemented
  - [ ] Basic tests written
  - [ ] Documentation updated
- [ ] **Component 2**: [Specific component description]
  - [ ] Core functionality implemented
  - [ ] Basic tests written
  - [ ] Documentation updated
- [ ] **Component 3**: [Specific component description]
  - [ ] Core functionality implemented
  - [ ] Basic tests written
  - [ ] Documentation updated

### Integration & Validation
- [ ] Components work together as expected
- [ ] Error handling implemented
- [ ] Edge cases handled
- [ ] All tests passing

### Final Review
- [ ] Code review completed
- [ ] Code style and conventions followed
- [ ] Documentation complete
- [ ] Success criteria met

## üéØ Success Criteria
- [Specific measurable outcome 1]
- [Specific measurable outcome 2]
- [Specific measurable outcome 3]

## ‚ö†Ô∏è Risk Considerations
- [Potential risk 1 and mitigation strategy]
- [Potential risk 2 and mitigation strategy]
- [Potential risk 3 and mitigation strategy]

## üìÖ Estimated Timeline
- **Planning Phase**: [X hours]
- **Implementation Phase**: [X hours]
- **Testing Phase**: [X hours]
- **Review & Documentation**: [X hours]
- **Total Estimated Time**: [X hours]
</implementation_plan>

**[PAUSE FOR USER CONFIRMATION]**

Please review the implementation plan above. Do you:
- Agree with the proposed approach?
- Want any modifications to the plan?
- Have any concerns about the timeline or approach?
- Need any clarifications about specific components?

Type "APPROVED" to proceed with execution, or provide your feedback for plan adjustments.

---

## Phase 4: Systematic Execution

Once the plan is approved, I will execute each step systematically, checking off items as we complete them.

### 4.1 Pre-Implementation Checklist Execution
   **ü§ñ AI Tool Recommendations:**
   - Use **analyze** for environment verification:
     ```
     Analyze the current development environment to ensure all dependencies 
     and tools are properly configured for this implementation
     ```

   **Progress Tracking:**
   - ‚úÖ Check off each item as completed
   - üîÑ Mark items in progress
   - ‚ùå Mark any blockers or issues encountered

### 4.2 Core Implementation Execution
   - Implement each component systematically
   - Follow established coding patterns and conventions
   - Write comprehensive tests for each component
   - Document code and architectural decisions
   - Commit changes incrementally with clear messages

   **ü§ñ AI Tool Recommendations:**
   - Use **debug** for systematic troubleshooting:
     ```
     If any implementation issues arise, use debug with gemini pro to 
     systematically investigate and resolve the problems
     ```
   - Use **refactor** for code quality improvement:
     ```
     Use refactor to improve code structure and maintainability while 
     implementing each component
     ```

   **Progress Tracking After Each Component:**
   ```
   ‚úÖ Component [X] - Core functionality complete
   ‚úÖ Component [X] - Unit tests written and passing
   ‚úÖ Component [X] - Documentation updated
   ‚úÖ Component [X] - Code review ready
   ```

### 4.3 Integration & Testing Execution
   - Integrate all components systematically
   - Run comprehensive test suites
   - Verify all acceptance criteria are met
   - Test error handling and edge cases
   - Perform security and performance validation

   **ü§ñ AI Tool Recommendations:**
   - Use **testgen** for additional test coverage:
     ```
     Use testgen to generate additional edge case tests that might have been 
     missed during initial implementation
     ```

### 4.4 Quality Assurance Execution
   - Perform thorough code review
   - Ensure all coding standards are met
   - Verify documentation completeness
   - Run all automated quality checks
   - Address any identified issues

   **ü§ñ AI Tool Recommendations:**
   - Use **codereview** for professional assessment:
     ```
     Use codereview to perform comprehensive code quality assessment with 
     severity levels for all implemented components
     ```
   - Use **precommit** for final validation:
     ```
     Use precommit-style validation to ensure all code meets quality 
     standards before final submission
     ```

### 4.5 Final Checklist Verification
   **After completing each major phase, provide status update:**
   ```
   ## üìä Progress Update
   
   ### Completed ‚úÖ
   - [List all completed checklist items with timestamps]
   
   ### In Progress üîÑ
   - [List any items currently being worked on]
   
   ### Pending ‚è≥
   - [List remaining items to be completed]
   
   ### Issues Encountered ‚ùå
   - [List any blockers or issues and their resolutions]
   ```

---

## üöÄ Advanced AI Tool Usage Patterns

### 1. **chat** - Collaborative Development & Problem Solving
Your thinking partner for brainstorming solutions, validating approaches, and making technical decisions throughout the development process.

**Example:**
```
Chat with o3 about the best approach for implementing this data validation 
feature while maintaining performance and code readability
```

### 2. **thinkdeep** - Extended Technical Analysis
Get deeper insights into complex implementation challenges, architectural decisions, and potential edge cases that might not be immediately obvious.

**Example:**
```
This caching mechanism seems straightforward, but use thinkdeep with gemini pro 
to analyze potential race conditions, memory leaks, and performance implications
```

### 3. **planner** - Systematic Task Breakdown
Break down complex development tasks into manageable, sequential steps with clear dependencies and deliverables.

**Pro Tip:** Use parallel planning to explore different implementation approaches, then use consensus to choose the best strategy!

**Example:**
```
Create two separate sub-tasks: in one, use planner to implement this feature 
using approach A. In the other, use planner for approach B. Once done, use 
consensus with o3 and gemini to determine which approach is more suitable
```

### 4. **consensus** - Multi-Model Technical Validation
Get diverse expert opinions on technical decisions, architecture choices, and implementation strategies with balanced perspectives.

**Example:**
```
Get a consensus with o3 taking a supportive stance and gemini pro being critical 
to evaluate whether this microservices architecture is appropriate for our use case
```

### 5. **debug** - Systematic Problem Resolution
When implementation issues arise, use systematic debugging approaches to identify root causes and implement effective solutions.

**Example:**
```
The authentication middleware isn't working as expected. Use debug with gemini pro 
to systematically investigate the request flow and identify the root cause
```

### 6. **testgen** - Comprehensive Test Coverage
Generate thorough test suites including unit tests, integration tests, and edge case scenarios to ensure robust implementation.

**Example:**
```
Use testgen to generate comprehensive test coverage for this payment processing 
module, including edge cases like network failures and invalid input scenarios
```

### 7. **Quick Tool Reference**
- **listmodels** - Check available AI models for any task
- **version** - Verify tool versions and configurations
- **analyze** - Quick code and project structure analysis
- **codereview** - Professional code quality assessment
- **refactor** - Code improvement and optimization
- **tracer** - System architecture and call-flow mapping
- **precommit** - Pre-submission validation and quality checks

---

## Important Guidelines:

### Planning Phase Best Practices:
- **Leverage AI Tools**: Use specialized AI tools for comprehensive analysis and planning
- **Seek Clarification**: Always ask clarifying questions before starting implementation
- **Think Systematically**: Break down complex tasks into manageable components
- **Consider Edge Cases**: Use AI tools to identify potential issues early
- **Plan for Quality**: Include testing, documentation, and review in your timeline

### Execution Phase Best Practices:
- **Follow the Checklist**: Systematically complete each planned item
- **Track Progress**: Provide regular status updates with completed items
- **Use Incremental Development**: Implement and test components incrementally
- **Document as You Go**: Keep documentation updated with implementation
- **Ask for Help**: Use AI tools when encountering implementation challenges

### Quality Assurance:
- **Multi-Model Validation**: Use consensus for important technical decisions
- **Comprehensive Testing**: Ensure thorough test coverage at all levels
- **Code Review**: Use AI-powered code review for quality assurance
- **Performance Considerations**: Test and validate performance requirements
- **Security Review**: Consider security implications of all implementations

### Communication & Feedback:
- **Regular Check-ins**: Provide progress updates throughout execution
- **Clear Status Reporting**: Use consistent formatting for progress updates
- **Issue Escalation**: Report blockers and challenges promptly
- **Success Validation**: Confirm completion against original success criteria

**Pro Tip**: For complex features, use planner with parallel sub-tasks to explore different approaches, then use consensus to choose the best implementation strategy before execution!
